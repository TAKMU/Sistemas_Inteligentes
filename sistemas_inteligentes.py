
import pandas as pd
import numpy as np
import random
PRODUCTS = pd.DataFrame({
    'Names' : ["Dubalin", "Chocolate", "Sabritas", "Gansitos", "Bubaloo", "Panditas", "Kranky"],
    'Weight' : [.6, 1, .1, .6, .4, .2, .3],
    'Buy_Price': [60, 30, 80, 66, 34, 76, 33],
    'Sale_Price' : [70, 80, 140, 100, 320, 43, 124]
    })

def init_population(n):
    """Return a population of n random solutions. Each solution is 
    a nx7 list, with each row representing the quantity of the products to buy.
    """
    new_population = np.random.randint(low=1, high=6, size=(n, 7))
    # print(new_population)
    return new_population

def fitness(candidate):
    """Return the score of the fit of the solution to the problem, considering 
    the earnings. It also considers the restrictions:
    - weight <= 20
    - spending <= 1000
    If the solution doesn't comply with the conditions, it will give a fitness of 0
    """
    result_weight = (PRODUCTS['Weight'] * candidate).sum()
    result_buy = (PRODUCTS['Buy_Price'] * candidate).sum()
    result_sale = (PRODUCTS['Sale_Price'] * candidate).sum()
    print(result_weight, result_buy, result_sale)
    if result_weight > 20:
        return 0
    if result_buy > 1000:
        return 0
    return result_sale - result_buy

def evaluation(population):
    """Return a population sorted by fitness."""
    return sorted(population, key= lambda x:fitness(x))

def selection(population):
    """Return top half of population."""
    return population[:len(population)//2]
def crossover(population,elitism=False):
    """Return a new population, generated by randomly pairing
    members of population (out-of-place). For each random pair,
    select a random pivot slot and generate 2 children:
    child1[j] = parent1[j],
    child2[j] = parent2[j], when j < pivot slot
    and
    child1[j] = parent2[j],
    child2[j] = parent1[j], when j >= pivot slot
    If elitism
        return parents and the child1s.
    Else
        return child1s and child2s
    """
    children = []
    n_pop = len(population)
    for i in range(n_pop): # Cross N times
        parent1,parent2 = random.sample(population,k=2)
        child1 = [[None for a in range(3)] for b in range(4)]
        child2 = [[None for a in range(3)] for b in range(4)]
        pivot = random.randrange(12) # Select a pivot slot.
        for j in range(12): # Iterate through slots
            o = j//3
            d = j%3
            if j < pivot:
                child1[o][d] = parent1[o][d]
                child2[o][d] = parent2[o][d]
            else:
                child1[o][d] = parent2[o][d]
                child2[o][d] = parent1[o][d]
        children.append(child1)
        if not elitism: children.append(child2)
    if elitism:
        return population+children
    else:
        return children
    
def mutation(population,p_mutate):
    """Return a mutated population (out-of-place). For each
    candidate, mutate with probability p_mutate.
    If mutate:
        Select random slot.
        Flip a coin whether to add or remove a random barrel.
    Else:
        The candidate is not affected.
    Return new (partially mutated) population.
    """
    mutated_population = []
    for candidate in population:
        if random.random() < p_mutate:
            # Mutate
            # Choose random slot
            o,d = random.randrange(4),random.randrange(3)
            if random.random() < 0.5 and len(candidate[o][d]) > 1:
                # Remove a barrel
                remove = random.choice(candidate[o][d])
                new_slot = [e for e in candidate[o][d] if e!=remove]
            else:
                # Add a barrel
                addable = list(set(ALPHABET)-(set(candidate[o][d])))
                add = random.choice(addable)
                new_slot = [e for e in candidate[o][d]] + [add]
            mutated_candidate = [[d for d in o] for o in candidate]
            mutated_candidate[o][d] = new_slot
        else:
            # Don't mutate
            mutated_candidate = [[d for d in o] for o in candidate]
        mutated_population.append(mutated_candidate)
    return mutated_population

print(ALPHABET)
p_mutate = 0.9
n_pop = 100
best_fitness = 9999# Initialize population

pop = init_population(n_pop)
pop = evaluation(pop)
i = 0
while best_fitness > 0:
    pop = selection(pop)
    pop = crossover(pop,elitism=True)
    pop = mutation(pop,0.5)
    pop = evaluation(pop)
    
    if fitness(pop[0]) < best_fitness:
        best_fitness = fitness(pop[0])
        print(f"New best fitness: {best_fitness} | i={i}")
    i+=1
        
print(pop[0])