
import pandas as pd
import random
PRODUCTS = {
    'Names' : ["Dubalin", "Chocolate", "Sabritas", "Gansitos", "Bubaloo", "Panditas"],
    'Weight' : [.6, 1, .1, .6, .4, .2, .3],
    'Buy_Price': [60, 100, 50, 200, 600, 500, 400],
    'Sale_Price' : [70, 400, 140, 320, 650, 600, 580],
    'Total' : [1, 1, 1, 1, 1, 1, 1, 1]
    }

def init_population(n):
    """Return a population of n random solutions. Each solution is 
    a list of 8 elements, with each element being the quantity of each product.
    """
    print([random.sample(range(1, 6), 7) for i in range(n)])
    return ([random.sample(range(1, 6), 7) for i in range(n)])


def fitness(candidate):
    """Return number of unique outcomes. Iterate through all
    possible pairs of poisonous barrels and the twelve slots.
    For each poisonous pair generate the outcome as a list
    e.g. [0,1,2,3], where the indexes are the orchids and
    numbers they day that orchid died (3 indicates that it
    did not die). Calculate the number of unique outcomes by
    adding outcomes o a set and return 66 - the length of
    that set. For a perfect solution there are 66 unique
    outcomes, thus return 0.
    """
    outcomes = set()
    values = []
    for quantity, i in enumerate(candidate): # Iterate through all poisonous barrels
        quantity * PRODUCTS[i][3]
        
        for o in range(4): # Orchid
            dead_orchid = False
            for d in range(3): # Day
                if not dead_orchid and any([p in candidate[o][d]
                                            for p in poisoned]):
                    dead_orchid = True
                    died_on.append(d)
                elif not dead_orchid and d==2:
                    died_on.append(3) # Add the "survive" token 3.
        outcomes.add(tuple(died_on))
    return 66 - len(outcomes)
def evaluation(population):
    """Return a population sorted by fitness."""
    return sorted(population, key= lambda x:fitness(x))
def selection(population):
    """Return top half of population."""
    return population[:len(population)//2]
def crossover(population,elitism=False):
    """Return a new population, generated by randomly pairing
    members of population (out-of-place). For each random pair,
    select a random pivot slot and generate 2 children:
    child1[j] = parent1[j],
    child2[j] = parent2[j], when j < pivot slot
    and
    child1[j] = parent2[j],
    child2[j] = parent1[j], when j >= pivot slot
    If elitism
        return parents and the child1s.
    Else
        return child1s and child2s
    """
    children = []
    n_pop = len(population)
    for i in range(n_pop): # Cross N times
        parent1,parent2 = random.sample(population,k=2)
        child1 = [[None for a in range(3)] for b in range(4)]
        child2 = [[None for a in range(3)] for b in range(4)]
        pivot = random.randrange(12) # Select a pivot slot.
        for j in range(12): # Iterate through slots
            o = j//3
            d = j%3
            if j < pivot:
                child1[o][d] = parent1[o][d]
                child2[o][d] = parent2[o][d]
            else:
                child1[o][d] = parent2[o][d]
                child2[o][d] = parent1[o][d]
        children.append(child1)
        if not elitism: children.append(child2)
    if elitism:
        return population+children
    else:
        return children
    
def mutation(population,p_mutate):
    """Return a mutated population (out-of-place). For each
    candidate, mutate with probability p_mutate.
    If mutate:
        Select random slot.
        Flip a coin whether to add or remove a random barrel.
    Else:
        The candidate is not affected.
    Return new (partially mutated) population.
    """
    mutated_population = []
    for candidate in population:
        if random.random() < p_mutate:
            # Mutate
            # Choose random slot
            o,d = random.randrange(4),random.randrange(3)
            if random.random() < 0.5 and len(candidate[o][d]) > 1:
                # Remove a barrel
                remove = random.choice(candidate[o][d])
                new_slot = [e for e in candidate[o][d] if e!=remove]
            else:
                # Add a barrel
                addable = list(set(ALPHABET)-(set(candidate[o][d])))
                add = random.choice(addable)
                new_slot = [e for e in candidate[o][d]] + [add]
            mutated_candidate = [[d for d in o] for o in candidate]
            mutated_candidate[o][d] = new_slot
        else:
            # Don't mutate
            mutated_candidate = [[d for d in o] for o in candidate]
        mutated_population.append(mutated_candidate)
    return mutated_population

print(ALPHABET)
p_mutate = 0.9
n_pop = 100
best_fitness = 9999# Initialize population

pop = init_population(n_pop)
pop = evaluation(pop)
i = 0
while best_fitness > 0:
    pop = selection(pop)
    pop = crossover(pop,elitism=True)
    pop = mutation(pop,0.5)
    pop = evaluation(pop)
    
    if fitness(pop[0]) < best_fitness:
        best_fitness = fitness(pop[0])
        print(f"New best fitness: {best_fitness} | i={i}")
    i+=1
        
print(pop[0])