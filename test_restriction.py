import pandas as pd
import numpy as np
import random
import math
import time

PRODUCTS = pd.DataFrame({
    'Names' : ["Dubalin", "Chocolate", "Sabritas", "Gansitos", "Bubaloo", "Panditas", "Kranky"],
    'Weight' : [.6, .5, .1, .6, 2, .2, .3],
    'Buy_Price': [60, 30, 80, 66, 34, 76, 33],
    'Sale_Price' : [70, 80, 140, 100, 170, 76, 124]
    })

n_product = len(PRODUCTS.index)
max_value = 7
min_value = 1

n_pop = 200
n_generations = 1000
p_mutate = 0.90
per_selection = 0.50

def init_population(n):
    """Return a population of n random solutions. Each solution is 
    a 4x3 list, with each element being a selection of 3 distinct
    random barrels.
    """
    global n_product
    new_population = np.random.randint(low=min_value, high=max_value, size=(n, n_product))
    return new_population

def fitness(candidate):
    """Give the score of the 
    """



    weight_limit = 15
    buy_limit = 1000
    result_weight = (PRODUCTS['Weight'] * candidate).sum()
    result_buy = (PRODUCTS['Buy_Price'] * candidate).sum()
    result_sale = (PRODUCTS['Sale_Price'] * candidate).sum()
    score = result_sale - result_buy
    negative = 0
    if result_weight > weight_limit:
        negative = (weight_limit - result_weight)* (result_sale / weight_limit)
    if result_buy > buy_limit:
        negative = negative + (buy_limit - result_buy) * (result_sale / buy_limit)
    if result_weight > weight_limit or result_buy > buy_limit:
        return score + negative
    score = result_sale - result_buy
    return score


def evaluation(population):
    """Return a population sorted by fitness."""
    return sorted(population, key= lambda x:fitness(x), reverse= True)

def selection(population, percentage_selection):
    """Return top half of population."""
    n_parents = math.ceil(len(population) * percentage_selection / 2) * 2
    n_parents = int(n_parents)
    return population[:n_parents]

def crossover(parents : np.array):
    """Return a new population, generated by pairing best solution with second best, and so forth. 
    """
    children = np.empty((len(parents), n_product), dtype=int)
    n_children = len(parents)
    for i in range(n_children): # Cross N times
        if i % 2 == 0:
            parent1, parent2 = parents[i], parents[i+1]
            child1 = np.empty(n_product)
            child2 = np.empty(n_product)
            child1[:int(n_product / 2)] = parent1[:int(n_product / 2)]
            child1[int(n_product / 2):] = parent2[int((n_product / 2)):]
            child2[:int(n_product / 2)] = parent2[:int(n_product / 2)]
            child2[int(n_product / 2):] = parent1[int(n_product / 2):]
            children[i] = child1
            children[i+1] = child2
    return children

def random_value(n):
    if random.random() < p_mutate: 
        o = random.randrange(1, 8)
        return o
    return n
    

def mutation(population):
    """Return a mutated population (out-of-place). For each
    candidate, mutate with probability p_mutate.
    If mutate:
        Select random slot.
        Select a randon integer to change the value excluding the preceding value.
    Else:
        The candidate is not affected.
    Return new (partially mutated) population.
    """
    mutate = np.vectorize(random_value)
    mutated_population = mutate(population)
    return mutated_population

def is_solution(candidate):
    weight_limit = 15
    buy_limit = 1000
    result_weight = (PRODUCTS['Weight'] * candidate).sum()
    result_buy = (PRODUCTS['Buy_Price'] * candidate).sum()
    if result_weight > weight_limit or result_buy > buy_limit:
        return False
    else: 
        return True

def gen_algorithm():
    pop = init_population(n_pop)
    ranking = evaluation(pop)

    for i in range(n_generations):
        parents = selection(ranking, per_selection)
        children = crossover(parents)
        children = mutation(children)
        new_pop = np.empty((n_pop, n_product), dtype=int)
        new_pop[:children.shape[0]] = children
        new_pop[children.shape[0]:] = pop[:(n_pop-children.shape[0])]
        pop = evaluation(new_pop)
    r_sol = []
    for com in pop:
        is_sol = is_solution(com)
        if is_sol:
            r_sol.append(com)
    pop = np.array(r_sol)
    solution = evaluation(pop)[0]
    return solution

print(PRODUCTS)


n_p = 50
n_g = 100
p_mutate = 0.3
per_selection = 0.7
for i in range(10, 12):
    n_pop = n_p * i
    for j in range(10, 16):
        n_generations = n_g * j
        with open('results_q.txt', 'a') as f:
            f.write("================== \n")
            f.write("population size: {0} \n generations: {1} \n mutation %: {2} \n selection %: {3} \n". format(n_pop, n_generations, p_mutate, per_selection))
        sol1 = []
        ran1 = []
        for k in range(10):
            st = time.time()
            solution = gen_algorithm()
            et = time.time()
            elapsed_time = et - st
            with open('results_q.txt', 'a') as f:
                f.write('Execution time: ' + str(elapsed_time) + ' seconds\n')
            sol1.append(solution)
            ran1.append(fitness(solution))
        with open('results_q.txt', 'a') as f:
            f.write("Ganancias \n")
            for score in ran1:
                f.write(str(score) + "\n")
            f.write("Mejor Soluci√≥n \n")
            f.write(str(sol1[ran1.index(max(ran1))]) + "\n")
            f.write("Max Ganancia \n")
            f.write(str(max(ran1)) + "\n")


