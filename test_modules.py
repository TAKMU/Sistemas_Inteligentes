import pandas as pd
import numpy as np
import random
import math

PRODUCTS = pd.DataFrame({
    'Names' : ["Dubalin", "Chocolate", "Sabritas", "Gansitos", "Bubaloo", "Panditas", "Kranky"],
    'Weight' : [.6, .5, .1, .6, 2, .2, .3],
    'Buy_Price': [60, 30, 80, 66, 34, 76, 33],
    'Sale_Price' : [70, 80, 140, 100, 170, 76, 124]
    })

n_product = len(PRODUCTS.index)
n_pop = 100
n_generations = 1000

def init_population(n):
    """Return a population of n random solutions. Each solution is 
    a 4x3 list, with each element being a selection of 3 distinct
    random barrels.
    """
    global n_product
    new_population = np.random.randint(low=1, high=7, size=(n, n_product))
    print(new_population)
    #new_population_df = pd.DataFrame({'Quantity' : new_population})
    return new_population

def fitness(candidate):
    """Return number of unique outcomes. Iterate through all
    possible pairs of poisonous barrels and the twelve slots.
    For each poisonous pair generate the outcome as a list
    e.g. [0,1,2,3], where the indexes are the orchids and
    numbers they day that orchid died (3 indicates that it
    did not die). Calculate the number of unique outcomes by
    adding outcomes o a set and return 66 - the length of
    that set. For a perfect solution there are 66 unique
    outcomes, thus return 0.
    """
    result_weight = (PRODUCTS['Weight'] * candidate).sum()
    result_buy = (PRODUCTS['Buy_Price'] * candidate).sum()
    result_sale = (PRODUCTS['Sale_Price'] * candidate).sum()
    if result_weight > 15:
        return (15 - result_weight) * 66.67
    if result_buy > 1000:
        return 1500 - result_buy
    return result_sale - result_buy

def evaluation(population):
    """Return a population sorted by fitness."""
    """
    for i in sorted(population, key= lambda x:fitness(x), reverse= True):
        print(fitness(i))
    """
    return sorted(population, key= lambda x:fitness(x), reverse= True)

def selection(population, percentage_selection):
    """Return top half of population."""
    n_parents = math.ceil(len(population) * percentage_selection / 2) * 2
    n_parents = int(n_parents)
    return population[:n_parents]

def crossover(parents : np.array, n_population):
    """Return a new population, generated by randomly pairing
    members of population (out-of-place). For each random pair,
    select a random pivot slot and generate 2 children:
    child1[j] = parent1[j],
    child2[j] = parent2[j], when j < pivot slot
    and
    child1[j] = parent2[j],
    child2[j] = parent1[j], when j >= pivot slot
    If elitism
        return parents and the child1s.
    Else
        return child1s and child2s
    """
    children = np.empty((len(parents), n_product), dtype=int)
    n_children = len(parents)
    for i in range(n_children): # Cross N times
        if i % 2 == 0:
            parent1, parent2 = parents[i], parents[i+1]
            child1 = np.empty(n_product)
            child2 = np.empty(n_product)
            child1[:int(n_product / 2)] = parent1[:int(n_product / 2)]
            child1[int(n_product / 2):] = parent2[int((n_product / 2)):]
            child2[:int(n_product / 2)] = parent2[:int(n_product / 2)]
            child2[int(n_product / 2):] = parent1[int(n_product / 2):]
            children[i] = child1
            children[i+1] = child2
    return children

per_selection = 0.60
print(PRODUCTS)
pop = init_population(n_pop)
for i in range(n_generations):
    print("iteration ", i)
    ranking = evaluation(pop)
    parents = selection(ranking, per_selection)
    children = crossover(parents, n_pop)
    pop = np.empty((n_pop, n_product), dtype=int)
    pop[:children.shape[0]] = children
    pop[children.shape[0]:] = parents[:n_pop-children.shape[0]]
    print("iteration ", i)
    print(pop)
    print("============")

solution = evaluation(pop)[0]
print(solution)
print(fitness(solution))